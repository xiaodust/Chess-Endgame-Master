<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>中国象棋 - 残局闯关</title>
    <style>
        /* 复用 index.html/mode_pve.html 的核心样式 */
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: #222;
            font-family: "KaiTi", "STKaiti", "Microsoft YaHei", serif;
            color: #eee;
            overflow: hidden;
            user-select: none;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .container {
            display: flex;
            width: 100%;
            height: 100%;
            padding: 10px;
            box-sizing: border-box;
            gap: 10px;
            position: relative;
        }

        /* --- 左侧：关卡列表 + 关卡信息 --- */
.sidebar-left {
            width: 18%;
            min-width: 180px;
            max-width: 260px;
            display: flex;
            flex-direction: column;
            gap: 1.5vh;
            padding: 1vh;
            box-sizing: border-box;
            overflow-y: auto;
}

        .level-list-panel {
            background-color: #333;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            border: 1px solid #444;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
            flex: 1.3; /* 左侧空间分配：列表 1.3 */
            overflow: hidden;
        }

        .level-info-panel {
            flex: 0.7; /* 关卡信息 0.7 */
            min-height: 0; /* 允许压缩 */
            background-color: #333;
            border-radius: 8px;
            border: 1px solid #444;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
            display: flex;
            flex-direction: column;
            padding: 10px;
            box-sizing: border-box;
        }

        /* --- AI 评价 --- */
        .eval-panel {
            flex: 1; /* AI 评价占左侧约 1/3 */
            min-height: 0; /* 允许压缩 */
            background-color: #333;
            border-radius: 8px;
            border: 1px solid #444;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
            display: flex;
            flex-direction: column;
        }

        .eval-content {
            flex: 1;
            padding: 15px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
        }
        .eval-score {
            font-size: clamp(1rem, 2.5vh, 1.6rem);
            font-weight: 900;
            margin-bottom: 1vh;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
        .score-good { color: #00e676; text-shadow: 0 0 10px rgba(0, 230, 118, 0.3); }
        .score-bad { color: #ff5252; text-shadow: 0 0 10px rgba(255, 82, 82, 0.3); }
        .score-warn { color: #ff9100; text-shadow: 0 0 10px rgba(255, 145, 0, 0.3); }
        .score-neutral { color: #ccc; }
        .eval-comment {
            font-size: clamp(0.95rem, 1.8vh, 1.1rem);
            color: #bbb;
            line-height: 1.4;
        }

        .sidebar-header {
            padding: 1vh;
            background-color: #444;
            border-bottom: 1px solid #555;
            text-align: center;
            font-size: clamp(1rem, 2vh, 1.2rem);
            font-weight: bold;
            color: #ffd700;
        }

        .level-list {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }

        .level-item {
            padding: 0.8vh 1vh;
            margin-bottom: 0.8vh;
            background-color: #2a2a2a;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border: 2px solid transparent;
        }

        .level-item:hover, .level-item:focus {
            background-color: #555;
            border-color: #fff;
            transform: scale(1.02);
            outline: none;
        }

        .level-item.active {
            background: linear-gradient(to right, #d32f2f, #b71c1c);
            border-color: #e57373;
        }
        
        .level-item.locked {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .level-title {
            font-size: clamp(1rem, 1.8vh, 1.2rem);
            font-weight: bold;
        }

        .level-status {
            font-size: clamp(0.9rem, 1.6vh, 1.1rem);
            color: #aaa;
        }

        .info-title {
            font-size: clamp(1rem, 2vh, 1.2rem);
            color: #ffd700;
            margin-bottom: 1vh;
            border-bottom: 1px solid #555;
            padding-bottom: 0.8vh;
        }

        .info-desc {
            font-size: clamp(0.95rem, 1.8vh, 1.1rem);
            color: #ccc;
            line-height: 1.5;
            flex: 1;
            overflow-y: auto;
        }

        /* --- 中间：棋盘区域 --- */
        .main-area {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #2a2a2a;
            border-radius: 8px;
            position: relative;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.8);
            border: 2px solid transparent;
        }

        /* 棋盘聚焦时的效果 - 移除边框，改用光标提示 */
        .main-area.focused {
            /* border-color: #ffd700; */
            /* box-shadow: 0 0 20px rgba(255, 215, 0, 0.5); */
            outline: none;
        }

        canvas {
            background-color: #dcb35c;
            background-image: repeating-linear-gradient(45deg, rgba(0,0,0,0.03) 0px, rgba(0,0,0,0.03) 2px, transparent 2px, transparent 4px),
                              linear-gradient(to bottom, #dcb35c, #cd9f4d);
            box-shadow: inset 0 0 80px rgba(50, 30, 0, 0.6), 0 30px 60px rgba(0,0,0,0.8);
            border: 6px solid #3d2608;
            border-radius: 6px;
            touch-action: none;
            outline: none;
        }

        /* --- 右侧：控制面板 --- */
.sidebar-right {
            width: 20%; /* 使用百分比宽度 */
            min-width: 180px;
            max-width: 260px;
            display: flex;
            flex-direction: column;
            gap: 1.5vh;
            padding: 1vh;
            box-sizing: border-box;
            overflow-y: auto;
}

        .panel-box {
            background-color: #333;
            padding: 1.2vh;
            border-radius: 8px;
            border: 1px solid #444;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }

        .panel-title {
            margin-bottom: 1.2vh;
            font-size: clamp(1rem, 2vh, 1.2rem);
            color: #ccc;
            border-bottom: 2px solid #d32f2f;
            padding-bottom: 0.8vh;
            display: inline-block;
        }

        .status-display {
            text-align: center;
            font-size: clamp(1rem, 2.2vh, 1.4rem);
            font-weight: bold;
            color: #ffd700;
            padding: 1.2vh;
            background-color: #222;
            border-radius: 4px;
            margin-bottom: 1.2vh;
        }
        .turn-red { color: #ff5252; }
        .turn-black { color: #448aff; }

.action-btn {
            width: 100%;
            padding: 1.2vh;
            margin-bottom: 1.2vh;
            font-size: clamp(0.95rem, 1.9vh, 1.15rem);
            border: 4px solid transparent;
            border-radius: 5px;
            cursor: pointer;
            font-family: inherit;
            color: white;
            transition: all 0.1s;
            box-shadow: 0 4px 0 rgba(0,0,0,0.3);
            font-weight: bold;
        }
        .action-btn:active { transform: translateY(3px); box-shadow: 0 1px 0 rgba(0,0,0,0.3); }
        .action-btn:hover, .action-btn:focus {
            filter: brightness(1.2);
            border-color: #fff;
            transform: scale(1.02);
            outline: none;
        }
        .btn-restart { background: linear-gradient(to bottom, #ff9800, #f57c00); }
        .btn-next { background: linear-gradient(to bottom, #2196f3, #1976d2); }
        .btn-back { background-color: #555; margin-top: auto; }
        .btn-disabled { background: #555; color: #888; cursor: not-allowed; box-shadow: none; }

        /* --- 胜率条 --- */
        .win-rate-container {
            width: 5%; /* 百分比宽度 */
            min-width: 40px;
            max-width: 80px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 0.5vh 0;
        }

        .win-rate-label {
            color: #ffd700;
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 2px;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }

        .win-rate-text {
            color: #fff;
            font-size: 1.1rem;
            margin-bottom: 8px;
            font-family: monospace;
        }

        .win-rate-bar {
            width: 24px;
            height: 80%;
            background: linear-gradient(to bottom, #1e88e5, #1565c0); /* 黑方背景 */
            border-radius: 8px;
            border: 2px solid #555;
            position: relative;
            overflow: hidden;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.5);
        }

        .win-rate-fill {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background: linear-gradient(to top, #d32f2f, #ef5350); /* 红方填充 */
            transition: height 0.5s ease-out;
            box-shadow: 0 0 10px rgba(244, 67, 54, 0.5);
        }

        .win-rate-icon {
            font-size: 1.5rem;
            font-weight: bold;
            margin: 5px 0;
        }

        /* 难度选择 */
        .difficulty-options {
            display: flex;
            flex-direction: column;
            gap: 1.2vh;
        }
        .radio-label {
            display: flex;
            align-items: center;
            cursor: pointer;
            padding: 0.8vh;
            border-radius: 4px;
            transition: background 0.2s;
            font-size: clamp(0.95rem, 1.9vh, 1.1rem);
            border: 2px solid transparent;
        }
        .radio-label:hover, .radio-label:focus-within { background-color: #444; border-color: #aaa; }
        .radio-label input { margin-right: 12px; transform: scale(1.2); }

        /* 提示遮罩 */
        .overlay-text {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 1.8rem;
            display: none;
            z-index: 20;
            pointer-events: none;
        }
        
        #check-alert {
            position: absolute;
            top: 40%; left: 50%;
            transform: translate(-50%, -50%);
            color: #d50000;
            font-size: 5rem;
            font-weight: 900;
            text-shadow: 2px 2px 0 #fff, -1px -1px 0 #fff, 1px -1px 0 #fff, -1px 1px 0 #fff, 1px 1px 0 #fff;
            pointer-events: none;
            display: none;
            z-index: 30;
            animation: pulse 0.8s infinite alternate;
        }
        @keyframes pulse {
            from { transform: translate(-50%, -50%) scale(1); opacity: 0.8;}
            to { transform: translate(-50%, -50%) scale(1.1); opacity: 1;}
        }

        /* 棋盘光标 */
        .cursor-box {
            position: absolute;
            width: 50px;
            height: 50px;
            border: 4px solid #ffd700; /* 金色光标 */
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.8);
            box-sizing: border-box;
            pointer-events: none;
            display: none;
            z-index: 10;
            transition: left 0.1s, top 0.1s, width 0.1s, height 0.1s; /* 增加尺寸过渡 */
        }
    </style>
</head>
<body>

<div class="container">
    <!-- 左侧：关卡列表 -->
    <div class="sidebar-left">
        <div class="level-list-panel">
            <div class="sidebar-header">关卡选择</div>
            <div id="level-list" class="level-list">
                <!-- 关卡列表项将由 JS 生成 -->
            </div>
        </div>
        
        <div class="level-info-panel">
            <div id="info-title" class="info-title">关卡信息</div>
            <div id="info-desc" class="info-desc">请选择一个关卡开始挑战。</div>
        </div>

        <div class="eval-panel">
            <div class="sidebar-header">AI 评价</div>
            <div class="eval-content">
                <div id="eval-score" class="eval-score score-neutral">--</div>
                <div id="eval-comment" class="eval-comment">等待对局开始...</div>
            </div>
        </div>
    </div>

    <!-- 中间：棋盘 -->
    <div class="main-area" id="main-area">
        <canvas id="xiangqi-board" tabindex="0"></canvas>
        <div id="thinking-overlay" class="overlay-text">电脑思考中...</div>
        <div id="check-alert">将军!</div>
        <div id="board-cursor" class="cursor-box"></div>
    </div>

    <!-- 胜率条 -->
    <div class="win-rate-container">
        <div class="win-rate-label">胜率</div>
        <div id="win-rate-text" class="win-rate-text">50%</div>
        <div class="win-rate-icon" style="color: #448aff;">黑</div>
        <div class="win-rate-bar">
            <div id="win-rate-fill" class="win-rate-fill" style="height: 50%;"></div>
        </div>
        <div class="win-rate-icon" style="color: #ff5252;">红</div>
    </div>

    <!-- 右侧：控制面板 -->
    <div class="sidebar-right">
        
        <div class="panel-box">
            <div id="turn-display" class="status-display turn-red">红方走棋</div>
            <div style="text-align: center; color: #aaa; margin-top: 5px; font-size: 0.9rem;">
                目标：红方获胜
            </div>
        </div>

        <!-- 难度设置 -->
        <div class="panel-box">
            <div class="panel-title">人机难度</div>
            <div class="difficulty-options">
                <label class="radio-label">
                    <input type="radio" name="difficulty" value="easy" onclick="game.setDifficulty('easy')"> 初级学徒
                </label>
                <label class="radio-label">
                    <input type="radio" name="difficulty" value="medium" checked onclick="game.setDifficulty('medium')"> 中级棋手
                </label>
                <label class="radio-label">
                    <input type="radio" name="difficulty" value="hard" onclick="game.setDifficulty('hard')"> 高级大师
                </label>
            </div>
        </div>

        <div class="panel-box" style="flex: 1; display: flex; flex-direction: column;">
            <div class="panel-title">挑战操作</div>
            <button class="action-btn btn-restart" onclick="game.reloadLevel()">重玩本关</button>
            <button id="btn-next" class="action-btn btn-next btn-disabled" onclick="game.nextLevel()">下一关</button>
            <div style="flex:1"></div>
            <button class="action-btn btn-back" onclick="window.location.href='home.html'">返回主页</button>
        </div>
    </div>
</div>

<script>
    const RED = 0;   
    const BLACK = 1; 
    
    // 关卡数据 - 来自 index.html
    const LEVELS = [
    { 
        id: 'L1', 
        title: '初出茅庐', 
        difficulty: '★', 
        desc: '入门杀法：利用红帅控制中路，红车底线一击制胜', 
        key: '白脸将杀法', 
        pieces: [
            { name: '帅', type: 'king', side: 'red', x: 5, y: 9 },
            { name: '车', type: 'rook', side: 'red', x: 6, y: 0 }, // 沉底车
            { name: '将', type: 'king', side: 'black', x: 4, y: 0 },
            { name: '士', type: 'advisor', side: 'black', x: 3, y: 0 }
        ]
    },
    { 
        id: 'L2', 
        title: '双鬼拍门', 
        difficulty: '★☆', 
        desc: '基础配合：双车占据咽喉要道，令对方将领无路可逃', 
        key: '双车错杀', 
        pieces: [
            { name: '帅', type: 'king', side: 'red', x: 5, y: 9 },
            { name: '车', type: 'rook', side: 'red', x: 3, y: 1 }, // 左肋
            { name: '车', type: 'rook', side: 'red', x: 5, y: 1 }, // 右肋，下一步可直接进车杀
            { name: '将', type: 'king', side: 'black', x: 4, y: 0 }
        ]
    },
    { 
        id: 'L3', 
        title: '马后炮', 
        difficulty: '★★', 
        desc: '经典战术：马控将门，炮打隔子，形成绝杀', 
        key: '马炮配合', 
        pieces: [
            { name: '帅', type: 'king', side: 'red', x: 5, y: 9 },
            { name: '马', type: 'horse', side: 'red', x: 4, y: 2 }, // 卧槽马/钓鱼马位
            { name: '炮', type: 'cannon', side: 'red', x: 4, y: 4 }, // 马后炮
            { name: '将', type: 'king', side: 'black', x: 4, y: 0 },
            { name: '士', type: 'advisor', side: 'black', x: 3, y: 0 }
        ]
    },
    { 
        id: 'L4', 
        title: '侧面虎', 
        difficulty: '★★☆', 
        desc: '立体攻势：车控横线，马跳挂角，黑将进退两难', 
        key: '挂角马', 
        pieces: [
            { name: '帅', type: 'king', side: 'red', x: 5, y: 9 },
            { name: '车', type: 'rook', side: 'red', x: 6, y: 0 }, // 控底线
            { name: '马', type: 'horse', side: 'red', x: 2, y: 2 }, // 准备跳(2,2)->(4,1)挂角
            { name: '将', type: 'king', side: 'black', x: 4, y: 0 },
            { name: '士', type: 'advisor', side: 'black', x: 5, y: 0 }
        ]
    },
    { 
        id: 'L5', 
        title: '铁门栓', 
        difficulty: '★★★', 
        desc: '中路突破：中炮镇住中路，红车底线强攻，无需照面', 
        key: '中炮封锁', 
        pieces: [
            { name: '帅', type: 'king', side: 'red', x: 5, y: 9 },
            { name: '炮', type: 'cannon', side: 'red', x: 4, y: 5 }, // 中炮
            { name: '车', type: 'rook', side: 'red', x: 2, y: 0 }, // 准备平车杀
            { name: '将', type: 'king', side: 'black', x: 4, y: 0 },
            { name: '士', type: 'advisor', side: 'black', x: 3, y: 0 },
            { name: '士', type: 'advisor', side: 'black', x: 5, y: 0 },
            { name: '象', type: 'elephant', side: 'black', x: 6, y: 0 } // 增加干扰
        ]
    },
    { 
        id: 'L6', 
        title: '困毙杀', 
        difficulty: '★★★☆', 
        desc: '运子技巧：红方无大子，需精确计算步数利用红兵困死黑将', 
        key: '冷着/困子', 
        pieces: [
            { name: '帅', type: 'king', side: 'red', x: 5, y: 9 },
            { name: '兵', type: 'pawn', side: 'red', x: 3, y: 1 }, // 高兵
            { name: '兵', type: 'pawn', side: 'red', x: 4, y: 2 }, // 低兵
            { name: '将', type: 'king', side: 'black', x: 4, y: 0 },
            { name: '士', type: 'advisor', side: 'black', x: 5, y: 0 }
        ]
    },
    { 
        id: 'L7', 
        title: '大海捞针', 
        difficulty: '★★★★', 
        desc: '攻守兼备：车炮兵三子联攻，需防备黑车反扑', 
        key: '顿挫与多子配合', 
        pieces: [
            { name: '帅', type: 'king', side: 'red', x: 4, y: 9 },
            { name: '车', type: 'rook', side: 'red', x: 8, y: 4 },
            { name: '炮', type: 'cannon', side: 'red', x: 2, y: 6 },
            { name: '兵', type: 'pawn', side: 'red', x: 4, y: 3 },
            { name: '将', type: 'king', side: 'black', x: 4, y: 0 },
            { name: '车', type: 'rook', side: 'black', x: 3, y: 2 },
            { name: '士', type: 'advisor', side: 'black', x: 5, y: 0 },
            { name: '象', type: 'elephant', side: 'black', x: 2, y: 0 }
        ]
    },
    { 
        id: 'L8', 
        title: '弃车保帅', 
        difficulty: '★★★★☆', 
        desc: '绝境反击：红车被中士阻挡，必须弃车砍士，才能让马炮形成杀势', 
        key: '弃子破士', 
        pieces: [
            { name: '帅', type: 'king', side: 'red', x: 5, y: 9 },
            { name: '车', type: 'rook', side: 'red', x: 4, y: 3 }, // 位置：(4,3) 面对中士，不能直接杀将
            { name: '马', type: 'horse', side: 'red', x: 2, y: 2 }, // 伏兵：挂角马位
            { name: '炮', type: 'cannon', side: 'red', x: 5, y: 4 }, // 助攻：中炮
            { name: '将', type: 'king', side: 'black', x: 4, y: 0 },
            { name: '士', type: 'advisor', side: 'black', x: 4, y: 1 }, // 关键阻挡：中士
            { name: '士', type: 'advisor', side: 'black', x: 5, y: 0 }, // 另一个士
            { name: '车', type: 'rook', side: 'black', x: 8, y: 1 }  // 黑方威胁
        ]
        // L8修正说明：
        // 1. 黑方只有2个士，符合规则。
        // 2. 红车(4,3)无法吃将，必须先吃掉(4,1)的士。
        // 3. 第一步：车四进二吃士（弃车）；第二步：将4进1吃车；第三步：马炮配合绝杀。
    },
    { 
        id: 'L9', 
        title: '蚯蚓降龙', 
        difficulty: '★★★★★', 
        desc: '以柔克刚：利用双兵连环，配合红帅，困死对方强力车马', 
        key: '兵卒连环', 
        pieces: [
            { name: '帅', type: 'king', side: 'red', x: 5, y: 9 },
            { name: '兵', type: 'pawn', side: 'red', x: 3, y: 2 }, 
            { name: '兵', type: 'pawn', side: 'red', x: 4, y: 2 },
            { name: '将', type: 'king', side: 'black', x: 4, y: 0 },
            { name: '车', type: 'rook', side: 'black', x: 7, y: 0 } // 黑车被红帅和兵限制
        ]
    },
    { 
        id: 'L10', 
        title: '珍珑棋局', 
        difficulty: '★★★★★+', 
        desc: '千古奇局：局面极其复杂，看似红方必死，需运用弃子、借力、顿挫等所有高级技巧', 
        key: '综合计算深度', 
        pieces: [
            { name: '帅', type: 'king', side: 'red', x: 4, y: 9 },
            { name: '车', type: 'rook', side: 'red', x: 1, y: 8 },
            { name: '马', type: 'horse', side: 'red', x: 7, y: 7 },
            { name: '炮', type: 'cannon', side: 'red', x: 2, y: 4 },
            { name: '兵', type: 'pawn', side: 'red', x: 5, y: 3 },
            { name: '将', type: 'king', side: 'black', x: 4, y: 0 },
            { name: '车', type: 'rook', side: 'black', x: 8, y: 0 },
            { name: '马', type: 'horse', side: 'black', x: 7, y: 2 },
            { name: '炮', type: 'cannon', side: 'black', x: 3, y: 2 },
            { name: '士', type: 'advisor', side: 'black', x: 5, y: 0 },
            { name: '象', type: 'elephant', side: 'black', x: 6, y: 0 }
        ]
    }
];

    const PIECE_VALUE = {
        'king': 10000, 'rook': 90, 'cannon': 45, 'horse': 40, 
        'elephant': 20, 'advisor': 20, 'pawn': 10
    };

    class XiangqiGame {
        constructor(canvasId) {
            this.canvas = document.getElementById(canvasId);
            this.ctx = this.canvas.getContext('2d');
            
            this.board = Array(10).fill(null).map(() => Array(9).fill(null));
            this.margin = 30;
            this.gridSize = 50; 
            
            this.turn = RED;
            this.isAIEnabled = true; 
            this.isThinking = false; 
            this.selected = null;
            this.moves = [];
            this.gameOver = false;
            this.currentLevelIndex = 0;
            this.difficulty = 'medium';
            this.lastScore = 0;
            this.cursor = { r: 9, c: 4 }; // 初始光标位置
            this.tt = new Map();
            this.maxUnlockedIndex = 0;
            
            // 初始化
            setTimeout(() => {
                try {
                    this.resize();
            this.loadUnlockState();
            this.renderLevelList();
            this.loadLevel(0);
            this.attachRightSidebarKeys();
        } catch (e) {
                    console.error("Async init failed:", e);
                    alert("游戏加载失败: " + e.message);
                }
            }, 100);

            window.addEventListener('resize', () => this.resize());
            
            const handleInput = (e) => {
                if(this.isThinking) return; 
                e.preventDefault();
                const rect = this.canvas.getBoundingClientRect();
                let clientX = e.changedTouches ? e.changedTouches[0].clientX : e.clientX;
                let clientY = e.changedTouches ? e.changedTouches[0].clientY : e.clientY;
                this.handleClick(clientX - rect.left, clientY - rect.top);
            };

            this.canvas.addEventListener('mousedown', handleInput);
            this.canvas.addEventListener('touchstart', handleInput, {passive: false});
            
            // 遥控器/键盘支持
            this.canvas.addEventListener('keydown', (e) => this.handleKey(e));
            this.canvas.addEventListener('focus', () => this.onFocus(true));
            this.canvas.addEventListener('blur', () => this.onFocus(false));
            
            // 初始聚焦棋盘
            setTimeout(() => this.canvas.focus(), 500);
        }

        onFocus(focused) {
            const area = document.getElementById('main-area');
            if (focused) {
                area.classList.add('focused');
                this.updateCursor();
            } else {
                area.classList.remove('focused');
                this.hideCursor();
            }
        }
        
        updateCursor() {
            const el = document.getElementById('board-cursor');
            if (!el) return;
            const gs = this.gridSize;
            const x = this.margin + this.cursor.c * gs;
            const y = this.margin + this.cursor.r * gs;
            const areaRect = document.getElementById('main-area').getBoundingClientRect();
            const canvasRect = this.canvas.getBoundingClientRect();
            const offsetLeft = canvasRect.left - areaRect.left + this.canvas.clientLeft;
            const offsetTop = canvasRect.top - areaRect.top + this.canvas.clientTop;
            el.style.width = gs + 'px';
            el.style.height = gs + 'px';
            el.style.left = (offsetLeft + x - gs/2) + 'px';
            el.style.top = (offsetTop + y - gs/2) + 'px';
            el.style.display = 'block';
        }
        
        hideCursor() {
            const el = document.getElementById('board-cursor');
            if (el) el.style.display = 'none';
        }

        handleKey(e) {
            if (this.isThinking) return;
            
            let handled = true;
            switch(e.key) {
                case 'ArrowUp':
                    if (this.cursor.r > 0) this.cursor.r--;
                    break;
                case 'ArrowDown':
                    if (this.cursor.r < 9) this.cursor.r++;
                    break;
                case 'ArrowLeft':
                    if (this.cursor.c > 0) {
                        this.cursor.c--;
                    } else {
                        // 焦点移动到左侧列表
                        this.focusSidebarLeft();
                        return;
                    }
                    break;
                case 'ArrowRight':
                    if (this.cursor.c < 8) {
                        this.cursor.c++;
                    } else {
                        // 焦点移动到右侧按钮
                        this.focusSidebarRight();
                        return;
                    }
                    break;
                case 'Enter':
                case ' ':
                case 'Ok': // 部分遥控器
                    this.handleCursorClick();
                    break;
                case 'Backspace':
                case 'Escape':
                    this.selected = null; this.moves = []; this.draw(); this.updateCursor();
                    break;
                default:
                    handled = false;
            }
            
            if (handled) {
                e.preventDefault();
                this.updateCursor();
                this.draw(); // 重绘以显示可能的高亮变化
            }
        }
        
        handleCursorClick() {
            if (this.selected && this.selected.r === this.cursor.r && this.selected.c === this.cursor.c) {
                this.selected = null; this.moves = []; this.draw(); this.updateCursor(); return;
            }
            const x = this.margin + this.cursor.c * this.gridSize;
            const y = this.margin + this.cursor.r * this.gridSize;
            this.handleClick(x, y);
        }
        
        focusSidebarLeft() {
            // 聚焦第一个关卡
            const firstLevel = document.querySelector('.level-item');
            if (firstLevel) firstLevel.focus();
        }
        
        focusSidebarRight() {
            const els = Array.from(document.querySelectorAll('.sidebar-right .difficulty-options .radio-label, .sidebar-right .action-btn'));
            const first = els.find(el => !el.disabled);
            if (first) first.focus();
        }

        attachRightSidebarKeys() {
            const els = Array.from(document.querySelectorAll('.sidebar-right .difficulty-options .radio-label, .sidebar-right .action-btn'));
            const isDisabledEl = (el) => (el.disabled === true) || el.classList.contains('btn-disabled');
            els.forEach((el, idx) => {
                el.tabIndex = 0;
                el.onkeydown = (e) => {
                    const k = e.key;
                    if (k === 'ArrowLeft') { e.preventDefault(); this.canvas.focus(); return; }
                    if (k === 'ArrowUp') {
                        e.preventDefault();
                        let j = idx - 1; while (j >= 0 && isDisabledEl(els[j])) j--;
                        if (j >= 0) els[j].focus(); return;
                    }
                    if (k === 'ArrowDown') {
                        e.preventDefault();
                        let j = idx + 1; while (j < els.length && isDisabledEl(els[j])) j++;
                        if (j < els.length) els[j].focus(); return;
                    }
                    if (k === 'Enter' || k === ' ' || k === 'Ok') {
                        e.preventDefault();
                        const input = el.querySelector('input');
                        if (input) { input.click(); return; }
                        el.click();
                        return;
                    }
                };
            });
        }

        resize() {
            const container = document.getElementById('main-area');
            if (!container) return;
            const rect = container.getBoundingClientRect();
            const maxWidth = rect.width - 40;
            const maxHeight = rect.height - 40;
            const hUnits = 9 + 1.2; 
            const wUnits = 8 + 1.2;
            const sizeByWidth = maxWidth / wUnits;
            const sizeByHeight = maxHeight / hUnits;
            
            this.gridSize = Math.floor(Math.min(sizeByWidth, sizeByHeight));
            this.margin = Math.floor(this.gridSize * 0.65);
            this.canvas.width = this.gridSize * 8 + this.margin * 2;
            this.canvas.height = this.gridSize * 9 + this.margin * 2;
            this.draw();
            this.updateCursor(); // Resize 时更新光标位置
        }

        renderLevelList() {
            const list = document.getElementById('level-list');
            if (!list) return;
            list.innerHTML = '';
            LEVELS.forEach((lvl, idx) => {
                const item = document.createElement('div');
                item.className = 'level-item' + (idx === this.currentLevelIndex ? ' active' : '') + (idx > this.maxUnlockedIndex ? ' locked' : '');
                item.tabIndex = 0; // 允许聚焦
                item.onclick = () => { if(idx <= this.maxUnlockedIndex) this.loadLevel(idx); };
                item.onkeydown = (e) => {
                     if(e.key === 'Enter' || e.key === ' ') {
                         if(idx <= this.maxUnlockedIndex) this.loadLevel(idx); 
                     }
                     if(e.key === 'ArrowRight') {
                         this.canvas.focus();
                         e.preventDefault();
                     }
                };
                item.innerHTML = `
                    <div class="level-title">${lvl.title}</div>
                    <div class="level-status">${lvl.difficulty}</div>
                `;
                list.appendChild(item);
            });
        }

        loadLevel(index) {
            this.currentLevelIndex = index;
            this.renderLevelList(); 
            
            const lvl = LEVELS[index];
            const infoTitle = document.getElementById('info-title');
            const infoDesc = document.getElementById('info-desc');
            if (infoTitle) infoTitle.textContent = lvl.title;
            if (infoDesc) infoDesc.textContent = lvl.desc;
            
            const btnNext = document.getElementById('btn-next');
            if (btnNext) {
                const unlocked = this.maxUnlockedIndex >= (this.currentLevelIndex + 1);
                if (unlocked) { btnNext.classList.remove('btn-disabled'); btnNext.disabled = false; }
                else { btnNext.classList.add('btn-disabled'); btnNext.disabled = true; }
            }

            // Init Board
            this.board = Array(10).fill(null).map(() => Array(9).fill(null));
            lvl.pieces.forEach(p => {
                // 兼容 index.html 的数据格式 (x/y/side) 和本文件的格式 (c/r/color)
                const r = p.y !== undefined ? p.y : p.r;
                const c = p.x !== undefined ? p.x : p.c;
                let color;
                if (p.side) {
                    color = p.side === 'red' ? RED : BLACK;
                } else {
                    color = p.color;
                }
                
                if (r !== undefined && c !== undefined && r >= 0 && r <= 9 && c >= 0 && c <= 8) {
                    this.board[r][c] = { type: p.type, color: color };
                }
            });

            this.turn = RED;
            this.selected = null;
            this.moves = [];
            this.gameOver = false;
            this.lastScore = 0;
            this.updateEvaluation(0);
            this.hideCheckAlert();
            
            // 重置光标到红帅位置
            const redKing = lvl.pieces.find(p => (p.side === 'red' || p.color === RED) && p.type === 'king');
            if (redKing) {
                const kr = redKing.y !== undefined ? redKing.y : redKing.r;
                const kc = redKing.x !== undefined ? redKing.x : redKing.c;
                this.cursor = { r: kr, c: kc };
            } else {
                this.cursor = { r: 9, c: 4 };
            }
            this.updateCursor();

            this.updateUI();
            this.draw();
            this.attachRightSidebarKeys();
        }

        setDifficulty(diff) {
            this.difficulty = diff;
        }

        reloadLevel() {
            this.loadLevel(this.currentLevelIndex);
        }

        nextLevel() {
            if (this.currentLevelIndex < LEVELS.length - 1) {
                this.loadLevel(this.currentLevelIndex + 1);
            } else {
                alert("恭喜！您已通关所有残局！");
            }
        }

        loadUnlockState() {
            try {
                const s = localStorage.getItem('xq_endgame_unlock_idx_v1');
                const v = s ? parseInt(s, 10) : 0;
                if (!Number.isNaN(v)) this.maxUnlockedIndex = Math.max(0, Math.min(v, LEVELS.length - 1));
            } catch {}
        }
        saveUnlockState() {
            try { localStorage.setItem('xq_endgame_unlock_idx_v1', String(this.maxUnlockedIndex)); } catch {}
        }

        handleClick(x, y) {
            if (this.gameOver) return;
            if (this.turn === BLACK) return; // AI turn

            const c = Math.round((x - this.margin) / this.gridSize);
            const r = Math.round((y - this.margin) / this.gridSize);

            if (r < 0 || r > 9 || c < 0 || c > 8) return;

            const target = this.board[r][c];

            if (target && target.color === this.turn) {
                this.selected = { r, c };
                this.moves = this.getLegalMoves(r, c, target);
                this.draw();
                return;
            }

            const move = this.moves.find(m => m.r === r && m.c === c);
            if (move) {
                this.makeMove(this.selected, {r, c}, target);
            }
        }

        makeMove(from, to, captured) {
            this.board[to.r][to.c] = this.board[from.r][from.c];
            this.board[from.r][from.c] = null;
            
            // 如果是红方走棋，评估这步棋的质量
            if (this.turn === RED) {
                const currentScore = this.evaluateBoard();
                this.evaluateMove(currentScore - this.lastScore);
                this.lastScore = currentScore;
            } else {
                this.lastScore = this.evaluateBoard();
            }

            if (captured && captured.type === 'king') {
                this.draw();
                setTimeout(() => this.handleWin(this.turn), 100);
                return;
            }

            this.checkGeneralLogic(this.turn);

            this.turn = 1 - this.turn;
            this.selected = null;
            this.moves = [];
            this.updateUI();
            this.draw();

            if (this.turn === BLACK && !this.gameOver) {
                this.triggerAIMove();
            }
        }
        
        // 评价红方走棋质量
        evaluateMove(delta) {
            const elScore = document.getElementById('eval-score');
            const elComment = document.getElementById('eval-comment');
            if (!elScore || !elComment) return;
            
            let comment = "";
            let scoreClass = "";
            let scoreText = "";

            if (delta <= -20) {
                scoreText = "妙手";
                scoreClass = "score-good";
                comment = "神来之笔！这步棋走得非常精妙！";
            } else if (delta <= -8) {
                scoreText = "好棋";
                scoreClass = "score-good";
                comment = "稳扎稳打，逐渐占据主动，继续保持！";
            } else if (delta >= 25) {
                scoreText = "败着";
                scoreClass = "score-bad";
                comment = "哎呀，这步棋是大失误，可能要丢子了！";
            } else if (delta >= 12) {
                scoreText = "劣手";
                scoreClass = "score-bad";
                comment = "这步棋不太理想，可能会陷入被动。";
            } else if (delta >= 5) {
                scoreText = "缓手";
                scoreClass = "score-warn";
                comment = "这步棋有些拖沓，错失了更好的进攻机会。";
            } else {
                scoreText = "平稳";
                scoreClass = "score-neutral";
                comment = "局面平稳，双方势均力敌。";
            }
            
            elScore.textContent = scoreText;
            elScore.className = "eval-score " + scoreClass;
            elComment.textContent = comment;
        }
        
        updateEvaluation(delta) {
            const elScore = document.getElementById('eval-score');
            const elComment = document.getElementById('eval-comment');
            if (!elScore || !elComment) return;
            elScore.textContent = "--";
            elScore.className = "eval-score score-neutral";
            elComment.textContent = "等待对局开始...";
        }
        
        handleWin(winnerColor) {
            this.gameOver = true;
            if (winnerColor === RED) {
                alert("闯关成功！");
                const btnNext = document.getElementById('btn-next');
                if (btnNext) { btnNext.classList.remove('btn-disabled'); btnNext.disabled = false; }
                const newUnlocked = Math.min(this.currentLevelIndex + 1, LEVELS.length - 1);
                if (newUnlocked > this.maxUnlockedIndex) {
                    this.maxUnlockedIndex = newUnlocked;
                    this.saveUnlockState();
                    this.renderLevelList();
                }
            } else {
                alert("闯关失败，请重试！");
            }
            this.updateUI();
        }

        updateUI() {
            const display = document.getElementById('turn-display');
            if (!display) return;
            if (this.gameOver) {
                display.textContent = "游戏结束";
                display.className = "status-display";
            } else {
                display.textContent = (this.turn === RED ? "红方" : "黑方") + "走棋";
                display.className = "status-display " + (this.turn === RED ? "turn-red" : "turn-black");
            }
            this.updateWinRate();
        }

        updateWinRate() {
            const score = this.evaluateBoard();
            const K = 50; 
            const redWinRate = 1 / (1 + Math.exp(score / K));
            const percentage = Math.min(Math.max(redWinRate * 100, 5), 95);
            
            const fill = document.getElementById('win-rate-fill');
            const text = document.getElementById('win-rate-text');
            if(fill) fill.style.height = percentage + '%';
            if(text) text.textContent = Math.round(percentage) + '%';
        }
        
        triggerAIMove() {
            this.isThinking = true;
            const overlay = document.getElementById('thinking-overlay');
            if (overlay) overlay.style.display = 'block';
            
            setTimeout(() => {
                const bestMove = this.getBestMove();
                this.isThinking = false;
                if (overlay) overlay.style.display = 'none';
                
                if (bestMove) {
                    const targetPiece = this.board[bestMove.toR][bestMove.toC];
                    this.makeMove(
                        {r: bestMove.fromR, c: bestMove.fromC},
                        {r: bestMove.toR, c: bestMove.toC},
                        targetPiece
                    );
                } else {
                    // 黑方无棋可走，红方胜
                    this.handleWin(RED);
                }
            }, 500);
        }

        getBestMove() {
            // 简单的 Minimax 用于残局应对
            const maxDepth = this.difficulty === 'easy' ? 2 : (this.difficulty === 'hard' ? 5 : 4);
            const timeLimit = this.difficulty === 'easy' ? 300 : (this.difficulty === 'hard' ? 1500 : 800);
            
            this.tt = new Map();
            const start = Date.now();
            let bestMove = null;

            // Iterative deepening if needed, but for now fixed depth is fine for endgame
            // To respect time limit, we could check time inside minimax
            
            const r = this.minimax(maxDepth, -Infinity, Infinity, true);
            return r.move;
        }

        minimax(depth, alpha, beta, isMaximizing) {
            if (depth === 0) return { score: this.evaluateBoard() };
            
            const color = isMaximizing ? BLACK : RED;
            let moves = this.generateAllLegalMoves(color);
            if (moves.length === 0) return { score: isMaximizing ? -100000 : 100000 };
            
            // 简单排序
            moves.sort((a, b) => {
                const ca = this.board[a.toR][a.toC];
                const cb = this.board[b.toR][b.toC];
                return (cb ? PIECE_VALUE[cb.type] : 0) - (ca ? PIECE_VALUE[ca.type] : 0);
            });

            let bestMove = null;
            if (isMaximizing) {
                let maxEval = -Infinity;
                for (let move of moves) {
                    const captured = this.board[move.toR][move.toC];
                    this.board[move.toR][move.toC] = this.board[move.fromR][move.fromC];
                    this.board[move.fromR][move.fromC] = null;
                    
                    if (captured && captured.type === 'king') {
                         // 恢复
                        this.board[move.fromR][move.fromC] = this.board[move.toR][move.toC];
                        this.board[move.toR][move.toC] = captured;
                        return { score: 100000 + depth, move };
                    }

                    const evalObj = this.minimax(depth - 1, alpha, beta, false);
                    let s = evalObj.score;
                    
                    this.board[move.fromR][move.fromC] = this.board[move.toR][move.toC];
                    this.board[move.toR][move.toC] = captured;

                    if (s > maxEval) { maxEval = s; bestMove = move; }
                    if (s > alpha) alpha = s;
                    if (beta <= alpha) break;
                }
                return { score: maxEval, move: bestMove };
            } else {
                let minEval = Infinity;
                for (let move of moves) {
                    const captured = this.board[move.toR][move.toC];
                    this.board[move.toR][move.toC] = this.board[move.fromR][move.fromC];
                    this.board[move.fromR][move.fromC] = null;
                    
                    if (captured && captured.type === 'king') {
                         this.board[move.fromR][move.fromC] = this.board[move.toR][move.toC];
                        this.board[move.toR][move.toC] = captured;
                        return { score: -100000 - depth, move };
                    }

                    const evalObj = this.minimax(depth - 1, alpha, beta, true);
                    let s = evalObj.score;
                    
                    this.board[move.fromR][move.fromC] = this.board[move.toR][move.toC];
                    this.board[move.toR][move.toC] = captured;

                    if (s < minEval) { minEval = s; bestMove = move; }
                    if (s < beta) beta = s;
                    if (beta <= alpha) break;
                }
                return { score: minEval, move: bestMove };
            }
        }

        evaluateBoard() {
            let score = 0;
            for (let r = 0; r < 10; r++) {
                for (let c = 0; c < 9; c++) {
                    const p = this.board[r][c];
                    if (p) {
                        let val = PIECE_VALUE[p.type];
                        if (p.color === BLACK) score += val; else score -= val;
                    }
                }
            }
            return score;
        }

        generateAllLegalMoves(color) {
            let moves = [];
            for(let r=0; r<10; r++) {
                for(let c=0; c<9; c++) {
                    const p = this.board[r][c];
                    if(p && p.color === color) {
                        const pieceMoves = this.getLegalMoves(r, c, p);
                        pieceMoves.forEach(m => {
                            moves.push({ fromR: r, fromC: c, toR: m.r, toC: m.c });
                        });
                    }
                }
            }
            return moves;
        }

        getLegalMoves(r, c, piece, ignoreKingCheck = false) {
            // 复用 PVE 的逻辑，这里为了简洁稍微压缩，但必须包含完整的规则
            let moves = [];
            const inBoard = (tr, tc) => tr >= 0 && tr <= 9 && tc >= 0 && tc <= 8;
            const isSelf = (tr, tc) => this.board[tr][tc] && this.board[tr][tc].color === piece.color;
            const add = (tr, tc) => moves.push({r: tr, c: tc});
            const scan = (dr, dc, isCannon) => {
                let tr = r + dr, tc = c + dc;
                let jump = false;
                while(inBoard(tr, tc)) {
                    if(!this.board[tr][tc]) { if(!isCannon || !jump) add(tr, tc); }
                    else { if(!isCannon || jump) { if(!isSelf(tr, tc)) add(tr, tc); break; } jump = true; }
                    tr += dr; tc += dc;
                }
            };

            switch(piece.type) {
                case 'rook': [[0,1],[0,-1],[1,0],[-1,0]].forEach(d => scan(d[0], d[1], false)); break;
                case 'cannon': [[0,1],[0,-1],[1,0],[-1,0]].forEach(d => scan(d[0], d[1], true)); break;
                case 'horse':
                    [[1,2],[1,-2],[-1,2],[-1,-2],[2,1],[2,-1],[-2,1],[-2,-1]].forEach(([dr, dc]) => {
                        const tr=r+dr, tc=c+dc;
                        const lr=r+(Math.abs(dr)===2?Math.sign(dr):0), lc=c+(Math.abs(dc)===2?Math.sign(dc):0);
                        if(inBoard(tr, tc) && !isSelf(tr, tc) && !this.board[lr][lc]) add(tr, tc);
                    }); break;
                case 'elephant':
                    [[2,2],[2,-2],[-2,2],[-2,-2]].forEach(([dr, dc]) => {
                        const tr=r+dr, tc=c+dc;
                        if(inBoard(tr, tc) && !isSelf(tr, tc)) {
                            const river = (piece.color === RED) ? tr >= 5 : tr <= 4;
                            if(river && !this.board[r+dr/2][c+dc/2]) add(tr, tc);
                        }
                    }); break;
                case 'advisor':
                    [[1,1],[1,-1],[-1,1],[-1,-1]].forEach(([dr, dc]) => {
                        const tr=r+dr, tc=c+dc;
                        if(inBoard(tr, tc) && !isSelf(tr, tc) && tc>=3 && tc<=5) {
                            if((piece.color===RED && tr>=7) || (piece.color===BLACK && tr<=2)) add(tr, tc);
                        }
                    }); break;
                case 'king':
                    [[0,1],[0,-1],[1,0],[-1,0]].forEach(([dr, dc]) => {
                        const tr=r+dr, tc=c+dc;
                        if(inBoard(tr, tc) && !isSelf(tr, tc) && tc>=3 && tc<=5) {
                            if((piece.color===RED && tr>=7) || (piece.color===BLACK && tr<=2)) add(tr, tc);
                        }
                    }); break;
                case 'pawn':
                    const dir = piece.color === RED ? -1 : 1;
                    const tr = r + dir;
                    if(inBoard(tr, c) && !isSelf(tr, c)) add(tr, c);
                    const crossed = (piece.color === RED && r <= 4) || (piece.color === BLACK && r >= 5);
                    if(crossed) { if(inBoard(r, c-1) && !isSelf(r, c-1)) add(r, c-1); if(inBoard(r, c+1) && !isSelf(r, c+1)) add(r, c+1); }
                    break;
            }

            if(ignoreKingCheck) return moves;
            return moves.filter(m => {
                const orig = this.board[m.r][m.c];
                this.board[m.r][m.c] = this.board[r][c];
                this.board[r][c] = null;
                let safe = true;
                if(this.isKingsFacing()) safe = false;
                this.board[r][c] = this.board[m.r][m.c];
                this.board[m.r][m.c] = orig;
                return safe;
            });
        }

        isKingsFacing() {
            let rK, bK;
            for(let i=0; i<10; i++) {
                for(let j=3; j<=5; j++) {
                    const p = this.board[i][j];
                    if(p && p.type === 'king') { if(p.color === RED) rK = {r:i, c:j}; else bK = {r:i, c:j}; }
                }
            }
            if(!rK || !bK || rK.c !== bK.c) return false;
            for(let i=bK.r+1; i<rK.r; i++) if(this.board[i][rK.c]) return false;
            return true;
        }

        checkGeneralLogic(attackerColor) {
            if (this.isOpponentInCheck(attackerColor)) this.showCheckAlert();
            else this.hideCheckAlert();
        }

        isOpponentInCheck(attackerColor) {
            const defenderColor = 1 - attackerColor;
            let kingPos = null;
            for(let r=0; r<10; r++) {
                for(let c=0; c<9; c++) {
                    const p = this.board[r][c];
                    if(p && p.color === defenderColor && p.type === 'king') { kingPos = {r, c}; break; }
                }
            }
            if(!kingPos) return false;
            for(let r=0; r<10; r++) {
                for(let c=0; c<9; c++) {
                    const p = this.board[r][c];
                    if(p && p.color === attackerColor) {
                        const moves = this.getLegalMoves(r, c, p, true);
                        if(moves.some(m => m.r === kingPos.r && m.c === kingPos.c)) return true;
                    }
                }
            }
            return false;
        }

        showCheckAlert() { 
            const el = document.getElementById('check-alert');
            if (el) el.style.display = 'block'; 
        }
        hideCheckAlert() { 
            const el = document.getElementById('check-alert');
            if (el) el.style.display = 'none'; 
        }
        
        getPieceName(p) {
            const map = { king: ['帅', '将'], advisor: ['仕', '士'], elephant: ['相', '象'], horse: ['马', '马'], rook: ['车', '车'], cannon: ['炮', '炮'], pawn: ['兵', '卒'] };
            return map[p.type][p.color];
        }

        draw() {
            if (!this.board) return;
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            this.drawGrid();
            this.drawPieces();
            this.drawHighlights();
        }

        drawGrid() {
            const ctx = this.ctx; const m = this.margin; const gs = this.gridSize;
            ctx.lineWidth = 2; ctx.strokeStyle = '#3d2608'; ctx.beginPath();
            for (let i = 0; i < 10; i++) { ctx.moveTo(m, m + i * gs); ctx.lineTo(m + 8 * gs, m + i * gs); }
            for (let i = 0; i < 9; i++) {
                if (i === 0 || i === 8) { ctx.moveTo(m + i * gs, m); ctx.lineTo(m + i * gs, m + 9 * gs); }
                else { ctx.moveTo(m + i * gs, m); ctx.lineTo(m + i * gs, m + 4 * gs); ctx.moveTo(m + i * gs, m + 5 * gs); ctx.lineTo(m + i * gs, m + 9 * gs); }
            }
            ctx.moveTo(m+3*gs, m); ctx.lineTo(m+5*gs, m+2*gs); ctx.moveTo(m+5*gs, m); ctx.lineTo(m+3*gs, m+2*gs);
            ctx.moveTo(m+3*gs, m+7*gs); ctx.lineTo(m+5*gs, m+9*gs); ctx.moveTo(m+5*gs, m+7*gs); ctx.lineTo(m+3*gs, m+9*gs);
            ctx.stroke();
            ctx.save();
            ctx.font = `${gs * 0.7}px "KaiTi", "楷体", serif`;
            ctx.fillStyle = '#3d2608';
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.translate(m + 4 * gs, m + 4.5 * gs); ctx.globalAlpha = 0.8;
            ctx.fillText("楚 河        汉 界", 0, 0);
            ctx.restore();
        }

        drawPieces() {
            const ctx = this.ctx; const gs = this.gridSize;
            for (let r = 0; r < 10; r++) {
                if (!this.board[r]) continue;
                for (let c = 0; c < 9; c++) {
                    const p = this.board[r][c];
                    if (!p) continue;
                    const x = this.margin + c * gs; const y = this.margin + r * gs; const radius = gs * 0.45;
                    const grad = ctx.createRadialGradient(x - radius*0.35, y - radius*0.35, radius*0.2, x, y, radius);
                    grad.addColorStop(0, '#e8cba5'); grad.addColorStop(0.6, '#cc9f60'); grad.addColorStop(1, '#8a5e20');
                    ctx.beginPath(); ctx.arc(x, y, radius, 0, 2 * Math.PI); ctx.fillStyle = grad; ctx.fill();
                    ctx.lineWidth = 2.5; ctx.strokeStyle = '#523108'; ctx.stroke();
                    ctx.beginPath(); ctx.arc(x, y, radius - 5, 0, 2 * Math.PI); ctx.lineWidth = 1; ctx.strokeStyle = '#caa574'; ctx.stroke();
                    ctx.fillStyle = (p.color === RED) ? '#cc0000' : '#111';
                    ctx.font = `bold ${gs * 0.6}px "KaiTi", "楷体", serif`;
                    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    ctx.fillText(this.getPieceName(p), x, y + 4);
                }
            }
        }

        drawHighlights() {
            const ctx = this.ctx; const gs = this.gridSize;
            if (this.selected) {
                const x = this.margin + this.selected.c * gs; const y = this.margin + this.selected.r * gs;
                ctx.strokeStyle = '#00e676'; ctx.lineWidth = 4; ctx.strokeRect(x - gs/2, y - gs/2, gs, gs);
            }
            this.moves.forEach(m => {
                const x = this.margin + m.c * gs; const y = this.margin + m.r * gs;
                ctx.beginPath();
                if (this.board[m.r][m.c]) { ctx.strokeStyle = 'rgba(255, 0, 0, 0.8)'; ctx.lineWidth = 4; ctx.arc(x, y, gs * 0.48, 0, 2 * Math.PI); ctx.stroke(); }
                else { ctx.fillStyle = 'rgba(16, 185, 129, 0.6)'; ctx.arc(x, y, gs * 0.18, 0, 2 * Math.PI); ctx.fill(); }
            });
        }
    }

    let game;
    try {
        game = new XiangqiGame('xiangqi-board');
    } catch(e) {
        console.error("Init failed:", e);
        alert("游戏初始化失败: " + e.message);
    }

</script>

</body>
</html>
